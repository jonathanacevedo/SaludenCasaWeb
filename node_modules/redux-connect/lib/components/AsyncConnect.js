'use strict';

exports.__esModule = true;
exports.AsyncConnect = undefined;

var _jsx2 = require('babel-runtime/helpers/jsx');

var _jsx3 = _interopRequireDefault(_jsx2);

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _Route = require('react-router/Route');

var _Route2 = _interopRequireDefault(_Route);

var _renderRoutes = require('react-router-config/renderRoutes');

var _renderRoutes2 = _interopRequireDefault(_renderRoutes);

var _utils = require('../helpers/utils');

var _state = require('../helpers/state');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var AsyncConnect = exports.AsyncConnect = function (_Component) {
  (0, _inherits3.default)(AsyncConnect, _Component);

  function AsyncConnect(props, context) {
    (0, _classCallCheck3.default)(this, AsyncConnect);

    var _this = (0, _possibleConstructorReturn3.default)(this, _Component.call(this, props, context));

    _this.state = {
      previousLocation: _this.isLoaded() ? null : props.location
    };

    _this.mounted = false;
    _this.loadDataCounter = 0;
    return _this;
  }

  AsyncConnect.prototype.componentDidMount = function componentDidMount() {
    this.mounted = true;
    var dataLoaded = this.isLoaded();

    // we dont need it if we already made it on server-side
    if (!dataLoaded) {
      this.loadAsyncData(this.props);
    }
  };

  AsyncConnect.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    var navigated = this.props.location !== nextProps.location;

    // Allow a user supplied function to determine if an async reload is necessary
    if (navigated && this.props.reloadOnPropsChange(this.props, nextProps)) {
      this.loadAsyncData(nextProps);
    }
  };

  AsyncConnect.prototype.componentWillUnmount = function componentWillUnmount() {
    this.mounted = false;
  };

  AsyncConnect.prototype.isLoaded = function isLoaded() {
    return (0, _state.getMutableState)(this.context.store.getState()).reduxAsyncConnect.loaded;
  };

  AsyncConnect.prototype.loadAsyncData = function loadAsyncData(props) {
    var _this2 = this;

    var store = this.context.store;

    var loadResult = (0, _utils.loadAsyncConnect)((0, _extends3.default)({}, props, { store: store }));

    this.setState({ previousLocation: this.props.location });

    // TODO: think of a better solution to a problem?
    this.loadDataCounter += 1;
    this.props.beginGlobalLoad();
    return function (loadDataCounterOriginal) {
      return loadResult.then(function () {
        // We need to change propsToShow only if loadAsyncData that called this promise
        // is the last invocation of loadAsyncData method. Otherwise we can face a situation
        // when user is changing route several times and we finally show him route that has
        // loaded props last time and not the last called route
        if (_this2.loadDataCounter === loadDataCounterOriginal && _this2.mounted !== false) {
          _this2.setState({ previousLocation: null });
        }

        // TODO: investigate race conditions
        // do we need to call this if it's not last invocation?
        _this2.props.endGlobalLoad();
      });
    }(this.loadDataCounter);
  };

  AsyncConnect.prototype.render = function render() {
    var _this3 = this;

    var previousLocation = this.state.previousLocation;
    var _props = this.props,
        location = _props.location,
        _render = _props.render;


    return (0, _jsx3.default)(_Route2.default, {
      location: previousLocation || location,
      render: function render() {
        return _render(_this3.props);
      }
    });
  };

  return AsyncConnect;
}(_react.Component);

AsyncConnect.contextTypes = {
  store: _propTypes2.default.object.isRequired
};
AsyncConnect.defaultProps = {
  helpers: {},
  reloadOnPropsChange: function reloadOnPropsChange() {
    return true;
  },
  render: function render(_ref) {
    var routes = _ref.routes;

    return (0, _renderRoutes2.default)(routes);
  }
};
exports.default = AsyncConnect;